<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1>Inteligencia Artificial Clase 1 15/08/2024</h1>
    <p>En esta clase se socializó los gustos y preferencias para la materia. También aprendimos a usar Github y Git.</p>
    <br>
    <div>
        <h2>Temas sugeridos:</h2>
        <img src="imagenes/temas sugeridos.jpg" alt="">
        <p>Vimos que datos se repetían y buscamos graficar de cierto que nos brindara dicha información en una grafica
            de pastel</p>
        <br>
    </div>
    <div>
        <h2>Actividades similares:</h2>
        <img src="imagenes/actividades similares.jpg" alt="">
        <p>Se agruparon las actividades que eran similares y se contaron manualmente</p>
        <br>
    </div>
    <div>
        <h2>Palabras repetidas:</h2>
        <img src="imagenes/columna S.jpg" alt="">
        <p>Elegimos la columna número 5 y sacamos las palabras repetidas con la ayuda de chatGPT y las rectificamos
            manualmente e hicimos lo mismo con las palabras únicas (que no se repetían)
            Luego último hicimos la suma de las palabras repetidas y también sacamos el número de palabras únicas y por
            último hicimos un gráfico circular 3D con los números de las palabras repetidas</p>
        <br>
    </div>
    <div>
        <h2>IAs usadas:</h2>
        <img src="imagenes/IA's usadas.jpg" alt="">
        <p>De manera manual tome los nombres de ias distintas y luego conté cuantas veces se repetía cada una, para al
            final juntar los valores y generar un anillo con Excel donde podemos ver que lo que vas se repite es chatgpt
        </p>
        <br>
    </div>
    <div>
        <h2>Nombres de IAs:</h2>
        <img src="imagenes/Nombres de IAs.jpg" alt="">
        <p>Yo utilice excel con formulas para sacar las palabras que estaban repetidas separando el texto y luego
            contando las palabras mas importantes de las inteligencias artificiales utilizando esta formula para contar
            las palabras que se repiten, SUMA(SI(NO(ESERROR(BUSCAR("chat";
            A25:AY41)));1;0))+SUMA(SI(NO(ESERROR(BUSCAR("chat gpt"; A25:AY41)));1;0))
        </p>
        <br>
    </div>
    <div>
        <h2>IAs:</h2>
        <img src="imagenes/IAs.jpg" alt="">
        <p>SE REALIZO UTILIZANDO FORMULA DE EXCEL Y TABLAS DINAMICAS.
        </p>
        <br>
    </div>
    <div>
        <h2>Habilidades blandas:</h2>
        <img src="imagenes/habilidades blandas.jpg" alt="">
        <p>Nos dimos cuenta que hay varias coincidencias y todas apuntan hacia el hecho de que todos contamos con
            habilidades blandas suficientes y exactas para llevar a cabo un excelente trabajo en equipo.
        </p>
        <br>
    </div>
    <div>
        <h2>Problemas de la sociedad:</h2>
        <img src="imagenes/Problemas de la sociedad.jpg" alt="">
        <p>Basicamente lo que hicimos fue indentificar, contar las palabras y finalmente estructuramos los resultados en
            una tabla de conteo que permite ver rápidamente la frecuencia de cada palabra y proporciona una vision
            general de los temas mas mencionados. los cuales son la inseguridad, contaminación y transporte
        </p>
        <br>
    </div>
    <div>
        <h1>Clase 2 22/08/2024</h1>
        <p>En esa clase vimos la definición de IA, sus conceptos filosóficos y algunos de los diferentes algoritmos de ordenamientos que hay con respecto a ella.</p>
    </div>
    <br>
    <div>
        <h1>Clase 3 29/08/2024</h1>
        <img src="https://www.codificandobits.com/img/posts/2018-09-03/dnn.png" alt="">
        <p>En esta clase se realizó la introducción a las redes neuronales, tomando como partida el reconocimiento de imágenes. Se explicó con un ejemplo
            de reconocer un número puesto en una imagen de 28x28 pixeles, dando como entrada un total de 724 nodos para su evaluación mediante el paso por 
            capas y así entregar una salida con el número identificado.
        </p>
    </div>
    <br>
    <div>
        <h1>Clase 4 12/09/2024</h1>
        <img src="data:image/png;base64,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" alt="">
        <p>El dia de hoy, se aprendió a construir una primera red neuronal usando Google Colab.
            Se importaron las librerias tensorflow y numpy para crear los arrays y las gráficas de nuestra red, tanto de una solo neurona de entrada y salida
            como de 3 capas intermedias posteriormente.
            Esta practica de la red neuronal, corresponde a la transformación de grados Celsius a Farehnheit, usando la fórmula básica para asi obtener el resultado.
        </p>
    </div>

    <br>
    <div>
        <style>
            table {
              font-family: arial, sans-serif;
              border-collapse: collapse;
              width: 100%;
            }
            
            td, th {
              border: 1px solid #dddddd;
              text-align: left;
              padding: 8px;
            }
            
            tr:nth-child(even) {
              background-color: #dddddd;
            }
            </style>
        <h1>Primer Parcial IA 26/09/2024</h1>
        <h3>Punto 3: Tabla comparativa del uso de DFS y BFS para resolver los laberintos</h3>
        <table>
            <tr>
              <th>Algoritmos</th>
              <th>DFS</th>
              <th>BFS</th>
            </tr>
            <tr>
              <td>Método usado</td>
              <td>StackFrontier()</td>
              <td>QueueFrontier()</td>
            </tr>
            <tr>
              <td>Nodos explorados laberinto 1</td>
              <td>265</td>
              <td>319</td>
            </tr>
            <tr>
              <td>Nodos explorados laberinto 2</td>
              <td>227</td>
              <td>331</td>
            </tr>
          </table>
    </div>

    <br>
    <h3>Punto 4: Código comentado explicando cada línea</h3>
   <pre>
     <code>
       # -*- coding: utf-8 -*-
       """Tu primera red neuronal en Python y Tensorflow"""
 
       import tensorflow as tf - Importa la biblioteca TensorFlow y la asigna a la variable tf.
       import numpy as np - Importa la biblioteca NumPy y la asigna a la variable np.
 
       celsius = np.array([-40, -10, 0, 8, 15, 22, 38], dtype=float) - Crea un arreglo NumPy con los valores de temperatura en Celsius y lo asigna a la variable celsius. El parámetro dtype=float especifica que los valores sean de tipo flotante.
       fahrenheit = np.array([-40, 14, 32, 46, 59, 72, 100], dtype=float) - Crea un arreglo NumPy con los valores de temperatura en Fahrenheit y lo asigna a la variable fahrenheit.
 
       #capa = tf.keras.layers.Dense(units=1, input_shape=[1])
       #modelo = tf.keras.Sequential([capa])
 
       oculta1 = tf.keras.layers.Dense(units=3, input_shape=[1]) - Crea una capa densa (completamente conectada) con 3 neuronas y la asigna a la variable oculta1. El parámetro input_shape=[1] especifica que la capa tenga una entrada de tamaño 1.
       oculta2 = tf.keras.layers.Dense(units=3) - Crea otra capa densa con 3 neuronas y la asigna a la variable oculta2.
       salida = tf.keras.layers.Dense(units=1) - Crea una capa densa con 1 neurona y la asigna a la variable salida.
       modelo = tf.keras.Sequential([oculta1, oculta2, salida]) - Crea un modelo secuencial que combina las capas oculta1, oculta2 y salida.
 
       modelo.compile(
           optimizer=tf.keras.optimizers.Adam(0.1),
           loss='mean_squared_error' - Compila el modelo con el optimizador Adam y la función de pérdida de error cuadrático medio. El parámetro 0.1 especifica la tasa de aprendizaje.
       )
 
       print("Comenzando entrenamiento...") - Imprime un mensaje indicando que el entrenamiento ha comenzado.
       historial = modelo.fit(celsius, fahrenheit, epochs=1000, verbose=False) - Entrena el modelo con los datos de temperatura en Celsius y Fahrenheit durante 1000 épocas. El parámetro verbose=False especifica que no se muestren mensajes de progreso.
       print("Modelo entrenado!") - Imprime un mensaje indicando que el entrenamiento ha terminado.
 
       import matplotlib.pyplot as plt - Importa la biblioteca Matplotlib para visualizar la pérdida.
       plt.xlabel("# Epoca") - Importa la biblioteca Matplotlib para visualizar la pérdida.
       plt.ylabel("Magnitud de pérdida") - Establece el título del eje y como "Magnitud de pérdida".
       plt.plot(historial.history["loss"]) - Plotea la pérdida durante el entrenamiento.
 
       print("Hagamos una predicción!") - Imprime un mensaje indicando que se hará una predicción.
       resultado = modelo.predict([100.0]) - Hace una predicción con una temperatura de 100 grados Celsius.
       print("El resultado es " + str(resultado) + " fahrenheit!") - Imprime el resultado de la predicción.
 
       print("Variables internas del modelo") - Imprime un mensaje indicando que se visualizarán las variables internas del modelo.
       #print(capa.get_weights())
       print(oculta1.get_weights()) - Imprime los pesos de la capa oculta1.
       print(oculta2.get_weights()) - Imprime los pesos de la capa oculta2.
       print(salida.get_weights()) - Imprime los pesos de la capa salida.
     </code>
   </pre>
   <br>
   <div>
    <h1>Clase 10/10/2024</h1>
    <img src="imagenes/Captura.JPG" alt="">
    <p>Se realizó una encuesta de acuerdo a diferentes actividades para así saber nuestros intereses y zona de trabajo más acorde.</p>
    Link para ver los resultados completos de la encuesta de intereses: https://drive.google.com/file/d/1ofvXrwjsWszs0wlAt940QJc7UfbLHcNB/view?usp=drive_link
    <br>
    <br>
    <br>
    <img src="imagenes/2.JPG" alt="">
    <p>Luego, se hizo la encuesta respecto a las carreas y enfoques profesionales</p>
    link para ver los resultados completos de la encuesta de carreras: https://drive.google.com/file/d/1rwMP7e9tBnX28VzrHAQs7_CFnlhX32Sz/view?usp=drive_link
    </div>
    <br>
    <h3>Código tictactoe comentado:</h3>
    <pre>
        <code>
import math  # Importa la biblioteca matemática para usar funciones como infinito.

# Definir los jugadores
HUMANO = -1  # Representa al jugador humano.
COMPUTADORA = 1  # Representa a la computadora.

# Crear el tablero vacío
tablero = [
    [0, 0, 0],  # Fila 0
    [0, 0, 0],  # Fila 1
    [0, 0, 0]   # Fila 2
]

# Función para verificar si hay un ganador
def ganador(tablero, jugador):
    # Define todas las combinaciones ganadoras posibles
    win_state = [
        [tablero[0][0], tablero[0][1], tablero[0][2]],  # Fila 0
        [tablero[1][0], tablero[1][1], tablero[1][2]],  # Fila 1
        [tablero[2][0], tablero[2][1], tablero[2][2]],  # Fila 2
        [tablero[0][0], tablero[1][0], tablero[2][0]],  # Columna 0
        [tablero[0][1], tablero[1][1], tablero[2][1]],  # Columna 1
        [tablero[0][2], tablero[1][2], tablero[2][2]],  # Columna 2
        [tablero[0][0], tablero[1][1], tablero[2][2]],  # Diagonal principal
        [tablero[2][0], tablero[1][1], tablero[0][2]],  # Diagonal secundaria
    ]
    # Comprueba si hay una combinación ganadora para el jugador
    return [jugador, jugador, jugador] in win_state

# Función para verificar si el tablero está lleno
def tablero_lleno(tablero):
    # Revisa cada fila del tablero
    for fila in tablero:
        if 0 in fila:  # Si hay un espacio vacío (0), retorna False
            return False
    return True  # Si no hay espacios vacíos, retorna True

# Evaluar el estado del tablero
def evaluar(tablero):
    # Comprueba si la computadora ha ganado
    if ganador(tablero, COMPUTADORA):
        return 1  # Retorna 1 si la computadora ha ganado
    # Comprueba si el humano ha ganado
    elif ganador(tablero, HUMANO):
        return -1  # Retorna -1 si el humano ha ganado
    else:
        return 0  # Retorna 0 si no hay ganadores

# Algoritmo Minimax
def minimax(tablero, profundidad, jugador):
    # Comprueba si la computadora ha ganado
    if ganador(tablero, COMPUTADORA):
        return 1  # Retorna 1 si la computadora ha ganado
    # Comprueba si el humano ha ganado
    if ganador(tablero, HUMANO):
        return -1  # Retorna -1 si el humano ha ganado
    # Comprueba si el tablero está lleno
    if tablero_lleno(tablero):
        return 0  # Retorna 0 si el tablero está lleno

    if jugador == COMPUTADORA:
        mejor = -math.inf  # Inicializa la mejor puntuación para la computadora
        # Recorre todas las posiciones del tablero
        for i in range(3):
            for j in range(3):
                if tablero[i][j] == 0:  # Si la posición está vacía
                    tablero[i][j] = COMPUTADORA  # Realiza el movimiento
                    mejor = max(mejor, minimax(tablero, profundidad + 1, HUMANO))  # Evalúa el movimiento
                    tablero[i][j] = 0  # Deshace el movimiento
        return mejor  # Retorna la mejor puntuación encontrada
    else:
        peor = math.inf  # Inicializa la peor puntuación para el humano
        # Recorre todas las posiciones del tablero
        for i in range(3):
            for j in range(3):
                if tablero[i][j] == 0:  # Si la posición está vacía
                    tablero[i][j] = HUMANO  # Realiza el movimiento
                    peor = min(peor, minimax(tablero, profundidad + 1, COMPUTADORA))  # Evalúa el movimiento
                    tablero[i][j] = 0  # Deshace el movimiento
        return peor  # Retorna la peor puntuación encontrada

# Movimiento de la computadora
def movimiento_computadora(tablero):
    mejor_mov imiento = None  # Inicializa el mejor movimiento
    mejor_valor = -math.inf  # Inicializa el mejor valor
    # Recorre todas las posiciones del tablero
    for i in range(3):
        for j in range(3):
            if tablero[i][j] == 0:  # Si la posición está vacía
                tablero[i][j] = COMPUTADORA  # Realiza el movimiento
                valor = minimax(tablero, 0, HUMANO)  # Evalúa el movimiento
                tablero[i][j] = 0  # Deshace el movimiento
                if valor > mejor_valor:  # Si el valor es mejor que el actual
                    mejor_valor = valor  # Actualiza el mejor valor
                    mejor_movimiento = (i, j)  # Actualiza el mejor movimiento
    return mejor_movimiento  # Retorna el mejor movimiento encontrado

# Imprimir el tablero
def imprimir_tablero(tablero):
    # Recorre cada fila del tablero
    for fila in tablero:
        print(fila)  # Imprime la fila

# Simulación de juego
def juego():
    while True:
        imprimir_tablero(tablero)  # Imprime el tablero actual
        if tablero_lleno(tablero):  # Comprueba si el tablero está lleno
            print("Empate!")  # Imprime el resultado en caso de empate
            break

        # Movimiento del humano
        fila = int(input("Introduce la fila (0, 1, 2): "))  # Pide la fila al humano
        col = int(input("Introduce la columna (0, 1, 2): "))  # Pide la columna al humano
        if tablero[fila][col] == 0:  # Si la posición está vacía
            tablero[fila][col] = HUMANO  # Realiza el movimiento
        else:
            print("Movimiento no válido, intenta de nuevo.")  # Imprime un mensaje de error
            continue

        if ganador(tablero, HUMANO):  # Comprueba si el humano ha ganado
            imprimir_tablero(tablero)  # Imprime el tablero final
            print("¡Has ganado!")  # Imprime el resultado
            break

        # Movimiento de la computadora
        movimiento = movimiento_computadora(tablero)  # Obtiene el mejor movimiento para la computadora
        tablero[movimiento[0]][movimiento[1]] = COMPUTADORA  # Realiza el movimiento

        if ganador(tablero, COMPUTADORA):  # Comprueba si la computadora ha ganado
            imprimir_tablero(tablero)  # Imprime el tablero final
            print("La computadora ha ganado.")  # Imprime el resultado
            break

# Iniciar el juego
juego()
        </code>
    </pre>
<br>
<br>
<div>
    <h2>Parcial 2 IA 24/10/2024</h2>
    <h3>Punto 5: Comentar código logic.py</h3>
</div>
<pre>
    <code>
        import itertools  # Importa la biblioteca itertools, aunque no se utiliza en este código.

class Sentence():
    """Clase base para representar oraciones lógicas."""

    def evaluate(self, model):
        """Evalúa la oración lógica."""
        raise Exception("nothing to evaluate")  # Lanza una excepción si se llama a este método sin implementación.

    def formula(self):
        """Devuelve la fórmula en forma de cadena que representa la oración lógica."""
        return ""

    def symbols(self):
        """Devuelve un conjunto de todos los símbolos en la oración lógica."""
        return set()

    @classmethod
    def validate(cls, sentence):
        """Valida que la oración sea una instancia de la clase Sentence."""
        if not isinstance(sentence, Sentence):
            raise TypeError("must be a logical sentence")  # Lanza un error si no es una oración lógica.

    @classmethod
    def parenthesize(cls, s):
        """Agrega paréntesis a una expresión si no está ya entre paréntesis."""
        def balanced(s):
            """Verifica si una cadena tiene paréntesis balanceados."""
            count = 0  # Contador para paréntesis.
            for c in s:
                if c == "(":
                    count += 1  # Incrementa el contador al encontrar un '('.
                elif c == ")":
                    if count <= 0:
                        return False  # Retorna False si hay un ')' sin un '(' correspondiente.
                    count -= 1  # Decrementa el contador al encontrar un ')'.
            return count == 0  # Retorna True si todos los paréntesis están balanceados.

        # Verifica si la cadena ya está balanceada o es una sola letra.
        if not len(s) or s.isalpha() or (
            s[0] == "(" and s[-1] == ")" and balanced(s[1:-1])
        ):
            return s  # Retorna la cadena tal como está.
        else:
            return f"({s})"  # Agrega paréntesis a la cadena.

class Symbol(Sentence):
    """Clase para representar un símbolo en la lógica."""

    def __init__(self, name):
        self.name = name  # Inicializa el símbolo con su nombre.

    def __eq__(self, other):
        """Verifica si dos símbolos son iguales."""
        return isinstance(other, Symbol) and self.name == other.name

    def __hash__(self):
        """Devuelve un hash del símbolo para su uso en conjuntos y diccionarios."""
        return hash(("symbol", self.name))

    def __repr__(self):
        """Representación en cadena del símbolo."""
        return self.name

    def evaluate(self, model):
        """Evalúa el símbolo en un modelo dado."""
        try:
            return bool(model[self.name])  # Retorna el valor booleano del modelo.
        except KeyError:
            raise EvaluationException(f"variable {self.name} not in model")  # Lanza una excepción si el símbolo no está en el modelo.

    def formula(self):
        """Devuelve la fórmula del símbolo."""
        return self.name

    def symbols(self):
        """Devuelve un conjunto con el símbolo."""
        return {self.name}


class Not(Sentence):
    """Clase para representar la negación de una oración."""

    def __init__(self, operand):
        Sentence.validate(operand)  # Valida el operando.
        self.operand = operand  # Inicializa con el operando.

    def __eq__(self, other):
        """Verifica si dos negaciones son iguales."""
        return isinstance(other, Not) and self.operand == other.operand

    def __hash__(self):
        """Devuelve un hash de la negación."""
        return hash(("not", hash(self.operand)))

    def __repr__(self):
        """Representación en cadena de la negación."""
        return f"Not({self.operand})"

    def evaluate(self, model):
        """Evalúa la negación en un modelo dado."""
        return not self.operand.evaluate(model)  # Retorna la negación del resultado del operando.

    def formula(self):
        """Devuelve la fórmula de la negación."""
        return "¬" + Sentence.parenthesize(self.operand.formula())  # Usa el símbolo de negación.

    def symbols(self):
        """Devuelve los símbolos del operando."""
        return self.operand.symbols()


class And(Sentence):
    """Clase para representar la conjunción de oraciones."""

    def __init__(self, *conjuncts):
        for conjunct in conjuncts:
            Sentence.validate(conjunct)  # Valida cada uno de los conjunctos.
        self.conjuncts = list(conjuncts)  # Inicializa la lista de conjunctos.

    def __eq__(self, other):
        """Verifica si dos conjunciones son iguales."""
        return isinstance(other, And) and self.conjuncts == other.conjuncts

    def __hash__(self):
        """Devuelve un hash de la conjunción."""
        return hash(
            ("and", tuple(hash(conjunct) for conjunct in self.conjuncts))
        )

    def __repr__(self):
        """Representación en cadena de la conjunción."""
        conjunctions = ", ".join([str(conjunct) for conjunct in self.conjuncts])
        return f"And({conjunctions})"

    def add(self, conjunct):
        """Agrega un nuevo conjuncto a la lista."""
        Sentence.validate(conjunct)
        self.conjuncts.append(conjunct)

    def evaluate(self, model):
        """Evalúa la conjunción en un modelo dado."""
        return all(conjunct.evaluate(model) for conjunct in self.conjuncts)  # Retorna True si todos los conjunctos son True.

    def formula(self):
        """Devuelve la fórmula de la conjunción."""
        if len(self.conjuncts) == 1:
            return self.conjuncts[0].formula()
        return " ∧ ".join([Sentence.parenthesize(conjunct.formula())
                           for conjunct in self.conjuncts])  # Usa el símbolo de conjunción.

    def symbols(self):
        """Devuelve los símbolos de todos los conjunctos."""
        return set.union(*[conjunct.symbols() for conjunct in self.conjuncts])


class Or(Sentence):
    """Clase para representar la disyunción de oraciones."""

    def __init__(self, *disjuncts):
        for disjunct in disjuncts:
            Sentence.validate(disjunct)  # Valida cada uno de los disyunctos.
        self.disjuncts = list(disjuncts)  # Inicializa la lista de disyunctos.

    def __eq__(self, other):
        """Verifica si dos disyunciones son iguales."""
        return isinstance(other, Or) and self.disjuncts == other.disjuncts

    def __hash__(self):
        """Devuelve un hash de la disyunción."""
        return hash(
            ("or", tuple(hash(disjunct) for disjunct in self.disjuncts))
        )

    def __repr__(self):
        """Representación en cadena de la disyunción."""
        disjuncts = ", ".join([str(disjunct) for disjunct in self.disjuncts])
        return f"Or({disjuncts})"

    def evaluate(self, model):
        """Evalúa la disyunción en un modelo dado."""
        return any(disjunct.evaluate(model) for disjunct in self.disjuncts)  # Retorna True si alguno de los disyunctos es True.

    def formula(self):
        """Devuelve la fórmula de la disyunción."""
        if len(self.disjuncts) == 1:
            return self.disjuncts[0].formula()
        return " ∨  ".join([Sentence.parenthesize(disjunct.formula())
                            for disjunct in self.disjuncts])  # Usa el símbolo de disyunción.

    def symbols(self):
        """Devuelve los símbolos de todos los disyunctos."""
        return set.union(*[disjunct.symbols() for disjunct in self.disjuncts])


class Implication(Sentence):
    """Clase para representar la implicación de oraciones."""

    def __init__(self, antecedent, consequent):
        Sentence.validate(antecedent)  # Valida el antecedente.
        Sentence.validate(consequent)  # Valida el consecuente.
        self.antecedent = antecedent  # Inicializa con el antecedente.
        self.consequent = consequent  # Inicializa con el consecuente.

    def __eq__(self, other):
        """Verifica si dos implicaciones son iguales."""
        return (isinstance(other, Implication)
                and self.antecedent == other.antecedent
                and self.consequent == other.consequent)

    def __hash__(self):
        """Devuelve un hash de la implicación."""
        return hash(("implies", hash(self.antecedent), hash(self.consequent)))

    def __repr__(self):
        """Representación en cadena de la implicación."""
        return f"Implication({self.antecedent}, {self.consequent})"

    def evaluate(self, model):
        """Evalúa la implicación en un modelo dado."""
        return ((not self.antecedent.evaluate(model))
                or self.consequent.evaluate(model))  # Retorna True si el antecedente es False o el consecuente es True.

    def formula(self):
        """Devuelve la fórmula de la implicación."""
        antecedent = Sentence.parenthesize(self.antecedent.formula())
        consequent = Sentence.parenthesize(self.consequent.formula())
        return f"{antecedent} => {consequent}"  # Usa el símbolo de implicación.

    def symbols(self):
        """Devuelve los símbolos del antecedente y el consecuente."""
        return set.union(self.antecedent.symbols(), self.consequent.symbols())


class Biconditional(Sentence):
    """Clase para representar la bicondicional de oraciones."""

    def __init__(self, left, right):
        Sentence.validate(left)  # Valida la parte izquierda.
        Sentence.validate(right)  # Valida la parte derecha.
        self.left = left  # Inicializa con la parte izquierda.
        self.right = right  # Inicializa con la parte derecha.

    def __eq__(self, other):
        """Verifica si dos bicondicionales son iguales."""
        return (isinstance(other, Biconditional)
                and self.left == other.left
                and self.right == other.right)

    def __hash__(self):
        """Devuelve un hash de la bicondicional."""
        return hash(("biconditional", hash(self.left), hash(self.right)))

    def __repr__(self):
        """Representación en cadena de la bicondicional."""
        return f"Biconditional({self.left}, {self.right})"

    def evaluate(self, model):
        """Evalúa la bicondicional en un modelo dado."""
        return ((self.left.evaluate(model)
                 and self.right.evaluate(model))
                or (not self.left.evaluate(model)
                    and not self.right.evaluate(model)))  # Retorna True si ambas partes son True o ambas son False.

    def formula(self):
        """Devuelve la fórmula de la bicondicional."""
        left = Sentence.parenthesize(str(self.left))
        right = Sentence.parenthesize(str(self.right))
        return f"{left} <=> {right}"  # Usa el símbolo de bicondicional.

    def symbols(self):
        """Devuelve los símbolos de ambas partes."""
        return set.union(self.left.symbols(), self.right.symbols())


def model_check(knowledge, query):
    """Verifica si el conocimiento implica la consulta."""

    def check_all(knowledge, query, symbols, model):
        """Verifica si el conocimiento implica la consulta en un modelo dado."""

        # Si el modelo tiene una asignación para cada símbolo
        if not symbols:

            # Si el conocimiento es True en el modelo, entonces la consulta debe ser True también
            if knowledge.evaluate(model):
                return query.evaluate(model)
            return True
        else:

            # Selecciona uno de los símbolos restantes
            remaining = symbols.copy()
            p = remaining.pop()

            # Crea un modelo donde el símbolo es True
            model_true = model.copy()
            model_true[p] = True

            # Crea un modelo donde el símbolo es False
            model_false = model.copy()
            model_false[p] = False

            # Verifica que la implicación se cumpla en ambos modelos
            return (check_all(knowledge, query, remaining, model_true) and
                    check_all(knowledge, query, remaining, model_false))

    # Obtiene todos los símbolos en ambos conocimiento y consulta
    symbols = set.union(knowledge.symbols(), query.symbols())

    # Verifica que el conocimiento implique la consulta
    return check_all(knowledge, query, symbols, dict())
    </code>
</pre>
<br>
<br>
<h3>Punto 6: Modificación y adaptación del archivo harry.py</h3>
<div>
    <pre>
        <code>
from logic import *  # Importa todas las clases y funciones definidas en el módulo logic.

# Definición de símbolos lógicos.
lluvia = Symbol("lluvia")  # Crea un símbolo que representa "lluvia".
bbc = Symbol("bbc")        # Crea un símbolo que representa "bbc".
Unimayor = Symbol("Unimayor")  # Crea un símbolo que representa "Unimayor".

# Definición del conocimiento lógico utilizando conjunciones y disyunciones.
knowledge = And(
    Implication(Not(lluvia), bbc),  # Si no hay lluvia, entonces hay bbc.
    Or(bbc, Unimayor),               # Hay bbc o hay Unimayor (o ambos).
    Not(And(bbc, Unimayor)),         # No puede ser que haya bbc y Unimayor al mismo tiempo.
    Unimayor                         # Hay Unimayor.
)

# Verifica si el conocimiento implica que hay lluvia.
print(model_check(knowledge, lluvia))  # Llama a la función model_check para evaluar si el conocimiento implica la proposición "lluvia".
        </code>
    </pre>
</div>

            
</body>

</html>
